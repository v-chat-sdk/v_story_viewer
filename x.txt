# AI Agent Directives: Flutter Development Standards

**Objective:** To ensure the highest quality, performance, and maintainability of the generated Flutter code, you must strictly adhere to the following rules and guidelines for every task. These are non-negotiable.

---

### 1. Development Approach
- Complete each task with working, testable code.
- Ensure no task leaves orphaned or unused code.
- **V-Prefix Naming:** All public APIs must follow the `V` prefix naming convention.
- **File Separation:** Maintain a strict separation of one class per file. **Each Flutter class or widget must be in its own separate `.dart` file.**
- Use sealed classes for enhanced type safety where applicable.
- Follow Flutter best practices for building widgets and structuring code.
- **Single Responsibility:** Adhere to the single responsibility principleâ€”each class should do only one thing.
- Prefer composition over inheritance where possible.
- **Resource Management:** Implement `dispose()` methods for all controllers and streams to prevent memory leaks.
- Use `const` constructors wherever possible for performance optimization.

### 2. Widget Building Guidelines
- Always use `const` for widgets that do not change.
- Prefer `StatelessWidget` when state is not needed.
- Extract complex widget trees into separate, smaller widget classes.
- Use `Key` types appropriately for widget identity and performance.
- Only use `AutomaticKeepAliveClientMixin` when absolutely necessary.
- Avoid deep widget nesting by extracting UI into methods or separate widgets.
- Use `Builder` widgets to obtain the correct `BuildContext` when needed.
- **Never call `setState()` during a build method.**
- Cache expensive computations using `late final` or other memoization techniques.

### 3. State Management Rules
- Controllers should extend `ChangeNotifier`, not manage multiple `ValueNotifier`s.
- Call `notifyListeners()` only after the state has actually changed.
- **Always dispose of controllers in the widget's `dispose()` method.**
- Use `WidgetsBindingObserver` to handle app lifecycle events.
- Avoid rebuilding the entire widget tree; use targeted rebuilds for efficiency.
- Implement proper error states within your controllers.
- Never expose mutable state directly; use getters to provide read-only access.


My request i need you to fix the behaviour of the following while i see users stories and navigate between and the current user
stories finished it should page me to the next user stories so fix this